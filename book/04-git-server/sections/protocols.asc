=== Protokol

Git dapat menggunakan empat protokol utama untuk mentransfer data: Lokal, HTTP, _Secure Shell_(SSH) dan Git.
Di sini kita akan membahas apa saja itu dan dalam keadaan dasar seperti apa Anda ingin (atau tidak ingin) menggunakannya.

==== Protokol Lokal

(((protocols, local)))
Hal yang paling mendasar adalah _Protokol lokal_, di mana repositori _remote_ berada dalam direktori lain pada _disk_.
Ini sering digunakan jika semua orang dalam tim Anda memiliki akses bersama terhadap filesistem seperti _mount_ NFS, atau pada kasus yang sering terjadi setiap orang masuk ke komputer yang sama.
Tidak masalah siapa yang terakhir, karena semua contoh kode repositori Anda akan tetap berada pada komputer yang sama, yang lebih mungkin terjadi adalah kerugian dan kehilangan data.

Jika Anda memiliki filesistem yang terpasang bersama, Anda dapat melakukan kloning, _push_, _pull_ dari dan ke repositori lokal yang berbasis berkas.
Untuk melakukan kloning sebuah repositori seperti ini atau menambahkannya sebagai _remote_ kedalam proyek yang sudah ada, gunakan jalur ke repositori sebagai URL.
Sebagai contoh, untuk mengkloning sebuah repositori lokal, Anda dapat melakukannya dengan cara seperti ini:

[source,console]
----
$ git clone /opt/git/project.git
----

Atau dapat dilakukan dengan cara:

[source,console]
----
$ git clone file:///opt/git/project.git
----

Git bekerja dengan cara yang sedikit berbeda jika Anda menentukan `file://` di awal URL secara eksplisit.
Jika Anda hanya menentukan jalurnya, Git akan mencoba menggunakan _hardlink_ atau menyalin berkas-berkas yang diperlukan secara langsung.
Jika Anda menentukan `file://`, Git akan mengaktifkan proses-proses yang biasanya digunakan untuk memindahkan data melalui jaringan yang umumnya merupakan metode yang kurang efisien dalam memindahkan data.
Alasan utama untuk menentukan awalan `file://` adalah jika Anda menginginkan sebuah salinan repositori yang bersih dengan meninggalkan referensi dan objek asing - biasanya setelah diimpor dari sistem kontrol versi lain atau yang serupa dengannya (lihat <<_git_internals>> untuk tugas-tugas perawatan).
Kita akan menggunakan jalur normal di sini karena hal ini akan menjadikannya lebih cepat.

Untuk menambahkan repositori lokal kedalam proyek Git yang sudah ada, Anda dapat menjalankan perintah seperti ini:

[source,console]
----
$ git remote add local_proj /opt/git/project.git
----

Lalu, Anda dapat melakukan _push_ dan _pull_ dari dan ke repositori _remote_ seperti Anda melakukannya melalui jaringan.

===== Pro

Repositori berbasis _file_ ini didukung karena terlihat lebih sederhana dan menggunakan hak akses berkas dan akses jaringan yang ada.
Jika Anda sudah memiliki sebuah sistem file bersama di mana seluruh tim Anda memiliki akses, mudah sekali membuat sebuah repositori.
Simpan salinan repositori kosong di suatu tempat yang dapat diakses secara bersama dan atur hak akses baca/tulis seperti yang Anda inginkan untuk direktori bersama lainya.
Kita akan membahas bagaimana mengekspor salinan repositori kosong untuk tujuan ini pada <<_git_on_the_server>>.

Ini juga merupakan pilihan yang bagus untuk mengambil pekerjaan dari repositori kerja orang lain dengan cepat. Jika Anda dan rekan kerja sedang mengerjakan proyek yang sama dan mereka ingin Anda memeriksa sesuatu, menjalankan perintah seperti `git pull /home/john/project` seringkali lebih mudah dari pada harus melakukan _pushing_  ke _server remote_ dan mengharuskan Anda untuk melakukan _pulling_ ke komputer lokal.

===== Kontra

Yang menjadi kontra dari metode ini bahwa akses bersama pada umumnya lebih sulit pada pengaturan dan untuk akses dari berbagai lokasi daripada akses jaringan dasar.
Jika Anda ingin melakukan _push_ dari laptop saat berada di rumah, Anda harus melakukan _mounting_ disk remote, yang bisa lebih sulit dan lambat jika dibandingkan dengan akses berbasis jaringan.

Penting juga untuk menyebutkan bahwa ini bukan merupakan pilihan tercepat jika Anda menggunakan _mount_ bersama.
Repositori lokal cepat hanya jika Anda memiliki akses yang cepat terhadap data.
Sebuah repositori pada NFS seringkali lebih lambat jika dibandingkan dengan repositori yang diakses melalui SSH pada _server_ yang sama, yang memungkinkan Git untuk menjalankan disk lokal pada setiap sistem.

==== Protokol HTTP

Git dapat berkomunikasi melalui HTTP dalam dua _mode_ yang berbeda.
Sebelum Git 1.6.6 hanya ada satu cara yang bisa dilakukan untuk melakukan hal ini dengan cara yang sangat sederhana dan umumnya hanya bisa dibaca.
Pada versi 1.6.6 sebuah protokol baru yang lebih cerdas diperkenalkan yang melibatkan kemampuan cerdas Git dalam melakukan transfer data dengan cara yang serupa ketika dilakukan melalui SSH.
Dalam beberapa tahun terakhir, protokol HTTP baru ini menjadi sangat terkenal karena lebih mudah bagi pengguna dan lebih pintar dalam cara berkomunikasi.
Versi yang lebih baru sering disebut sebagai protokol ``Smart'' HTTP dan yang lama disebut sebagai protokol ``Dumb'' HTTP.
Kami akan membahas protokol ``Smart'' HTTP terlebih dahulu.

===== Smart HTTP

(((protocols, smart HTTP)))
Protokol ``Smart'' HTTP beroperasi dengan cara yang sama seperti protokol SSH atau Git namun berjalan melalui port standar HTTP/S dan dapat menggunakan bermacam mekanisme otentikasi HTTP, artinya seringkali lebih mudah bagi si pengguna dari pada menggunakan SSH, karena Anda dapat menggunakan hal-hal seperti otentikasi dasar nama pengguna/kata sandi dari pada harus mengatur kunci SSH.

Mungkin ini telah menjadi cara yang paling populer dalam menggunakan Git sekarang ini, karena keduanya dapat diatur untuk berfungsi secara anonim seperti protokol `git://`, dan juga dapat dilakukan _pushing_ dengan otentikasi dan enkripsi seperti protokol SSH. Daripada harus menyiapkan URL yang berbeda untuk hal-hal seperti ini, sekarang Anda dapat menggunakan satu URL untuk keduanya. Jika Anda melakukan _push_ sedangkan repositori mengharuskan otentikasi (yang memang begitu seharusnya), _server_ dapat meminta nama pengguna dan kata sandi. Hal ini juga berlaku untuk akses baca.

Sebenarnya, untuk layanan seperti GitHub, URL yang Anda gunakan untuk melihat sebuah repositori yang daring (contohnya, ``https://github.com/schacon/simplegit[]'') merupakan URL yang sama yang dapat Anda gunakan untuk mengkloning, dan jika Anda memiliki akses terhadapnya, Anda dapat melakukan _push_ ke repositori tersebut.

===== Dumb HTTP

(((protocols, dumb HTTP)))
Jika server tidak menanggapi layanan _smart_ HTTP Git, maka klien akan mencoba untuk kembali menggunakan protokol ``dumb'' HTTP yang lebih sederhana.
Protokol _Dumb_ mengharapkan repositori Git yang kosong disajikan seperti berkas yang normal dari _server_ web.
Yang menarik dari protokol HTTP _Dumb_ adalah kesederhanaan pengaturannya.
Pada dasarnya, yang harus Anda lakukan adalah meletakkan sebuah repositori Git kosong di bawah _root_ dokumen HTTP Anda dan mengaitkannya dengan `post-update` tertentu, dan selesai (Lihat <<_git_hooks>>).
Pada tahap itu, siapa saja yang dapat mengakses _server_ web tempat Anda meletakkan repositori juga dapat mengkloning repositori Anda.
Untuk mengizinkan akses baca ke repositori Anda mealui HTTP, lakukanlah seperti ini:

[source,console]
----
$ cd /var/www/htdocs/
$ git clone --bare /jalur/ke/proyek_git gitproject.git
$ cd gitproject.git
$ mv hooks/post-update.sample hooks/post-update
$ chmod a+x hooks/post-update
----

Itu saja.(((hooks, post-update)))
Kaitan `post-update` yang hadir bersama Git secara _default_ menjalankan perintah yang tepat (`git update-server-info`) untuk membuat _fetching_ dan _cloning_ HTTP bekerja dengan semestinya.
Perintah ini dijalankan saat Anda melakukan _push_ ke repositori ini (mungkin melalui SSH); maka orang lain dapat melakukan _clone_ dengan cara seperti ini

[source,console]
----
$ git clone https://example.com/gitproject.git
----
Pada kasus ini, kami menggunakan jalur `/var/www/htdocs` yang umum digunakan untuk pengaturan Apache, namun Anda dapat menggunakan _server_ web statis - cukup dengan meletakkan repositori kosong di jalurnya.
Data Git berfungsi sebagai _file_ statis dasar (lihat <<_git_internals>> untuk rincian tentang bagaimana cara kerjanya).

Umumnya Anda akan memilih untuk menjalankan _server_ _Smart_ HTTP dengan akses baca/tulis atau hanya memiliki _file_ yang dapat diakses sebagai baca-saja pada kondisi _Dumb_ HTTP. Jarang sekali menjalankan perpaduan dari dua layanan ini.

===== Pro

Kami akan berkonsentrasi pada dukungan dari versi Smart dari protokol HTTP.

Salah satu kesederhanaan memiliki satu URL untuk semua jenis akses dan mengharuskan pengguna untuk mengisi kembali data untuk otentikasi yang ditampilkan oleh layar _server_ membuat semuanya sangat mudah bagi pengguna akhir.
Mampu mengotentikasi dengan menggunakan nama pengguna dan kata sandi juga merupakan keuntungan besar dari SSH, karena pengguna tidak perlu menghasilkan kunci SSH secara lokal dan mengunggah kunci publik mereka ke server sebelum dapat berinteraksi dan bekerja dengannya.
Untuk pengguna yang kurang berpengalaman, atau pengguna sistem di mana SSH kurang umum digunakan, kegunaan ini merupakan keuntungan yang utama.
Juga merupakan protokol yang sangat cepat dan efisien, mirip dengan SSH.

Anda juga dapat menjalankan repositori Anda dengan status baca-saja melalui HTTPS, yang berarti Anda dapat memindahkan konten data dalam keadaan terenkripsi; atau lebih lanjut dapat dilakukan dengan membuat klien menggunakan sertifikat SSL yang ditandatangani khusus.

Hal menarik lainnya adalah bahwa HTTP/S merupakan protokol yang umum digunakan sehingga _firewall-firewall_ yang digunakan pada perusahaan sering dibuat untuk memungkinkan lalu lintas jaringan melalui _port_ ini.

===== Kontra

Penggunaag Git melalui HTTP/S bisa sedikit lebih rumit dalam pengaturannya jika dibandingkan dengan SSH pada beberapa _server_.
Selain itu, protokol-protokol yang lain memiliki sedikit sekali keuntungan jika dibandingkan dengan protokol ``Smart'' HTTP dalam menjalankan Git.

Jika Anda menggunakan HTTP untuk melakukan _pushing_ yang terotentikasi, memberikan kredensial Anda terkadang menjadi lebih rumit jika dibandingkan dengan menggunakan kunci melalui SSH. Namun ada beberapa perkakas _caching_ kredensial yang dapat Anda gunakan, termasuk akses _Keychain_ pada OSX dan _Credential Manager_ di Windows, untuk menjadikannya lebih mudah. Baca <<_credential_caching>> untuk melihat bagaimana menyiapkan _caching_ kata sandi HTTP yang aman di sistem Anda.

==== Protokol SSH

(((protocols, SSH)))
Protokol transportasi yang umum digunakan untuk Git jika melakukan _hosting_ sendiri adalah melalui SSH.
Hal ini dikarenakan akses melalui SSH ke _server_ sudah diatur pada kebanyakan sistem - dan jika tidak, cukup mudah untuk melakukannya.
SSH juga merupakan sebuah protokol jaringan yang terotentikasi; dan karena itu ada di mana-mana, umumnya mudah untuk dipasang dan digunakan.

Untuk melakukan _clone_ sebuah repositori Git melalui SSH, Anda dapat menentukan ssh:// URL seperti ini:

[source,console]
----
$ git clone ssh://user@server/project.git
----

Atau Anda dapat menggunakan sintaks yang lebih singkat seperti sintaks _secure copy_ untuk protokol SSH:

[source,console]
----
$ git clone user@server:project.git
----

Anda juga dapat tidak mencantumkan nama pengguna, dan Git akan menganggap pengguna yang saat ini masuk sebagai Anda.

===== Pro

Ada banyak keuntungan menggunakan SSH.
Pertama, SSH relatif mudah diatur - _daemon_ SSH sudah biasa digunakan, banyak administrator jaringan juga memiliki pengalaman menggunakannya, dan kebanyakan distribusi Sistem Operasi disiapkan untuk menggunakan SSH atau memiliki perkakas untuk mengelolanya.
Selanjutnya, akses melalui SSH lebih aman - semua transfer data terenkripsi dan terkonfirmasi.
Terakhir, seperti halnya protokol HTTP/S, Git dan Lokal, SSH lebih efisien, menjadikan data serapi mungkin sebelum mentransfernya.

===== The Cons

The negative aspect of SSH is that you can't serve anonymous access of your repository over it.
People must have access to your machine over SSH to access it, even in a read-only capacity, which doesn't make SSH access conducive to open source projects.
If you're using it only within your corporate network, SSH may be the only protocol you need to deal with.
If you want to allow anonymous read-only access to your projects and also want to use SSH, you’ll have to set up SSH for you to push over but something else for others to fetch over.

==== The Git Protocol

(((protocols, git)))
Next is the Git protocol.
This is a special daemon that comes packaged with Git; it listens on a dedicated port (9418) that provides a service similar to the SSH protocol, but with absolutely no authentication.
In order for a repository to be served over the Git protocol, you must create the `git-daemon-export-ok` file – the daemon won't serve a repository without that file in it – but other than that there is no security.
Either the Git repository is available for everyone to clone or it isn't.
This means that there is generally no pushing over this protocol.
You can enable push access; but given the lack of authentication, if you turn on push access, anyone on the internet who finds your project's URL could push to your project.
Suffice it to say that this is rare.

===== The Pros

The Git protocol is often the fastest network transfer protocol available.
If you’re serving a lot of traffic for a public project or serving a very large project that doesn't require user authentication for read access, it’s likely that you'll want to set up a Git daemon to serve your project.
It uses the same data-transfer mechanism as the SSH protocol but without the encryption and authentication overhead.

===== The Cons

The downside of the Git protocol is the lack of authentication.
It's generally undesirable for the Git protocol to be the only access to your project.
Generally, you'll pair it with SSH or HTTPS access for the few developers who have push (write) access and have everyone else use `git://` for read-only access.
It's also probably the most difficult protocol to set up.
It must run its own daemon, which requires `xinetd` configuration or the like, which isn't always a walk in the park.
It also requires firewall access to port 9418, which isn't a standard port that corporate firewalls always allow.
Behind big corporate firewalls, this obscure port is commonly blocked.
